##jvm的类加载机制
一个Java文件经过javac编译成一个或多个class文件，这些文件需要被加载到
jvm内存中才能被jvm操作调用。

Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：
加载->连接(验证-准备-解析)->初始化->使用->卸载

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序
按部就班地开始（开始的顺序是确定的，但结束的顺序则不确定，也就是说不必等上一阶段运行结束后才开始下一阶段），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。

###加载
在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下三件事情：
1. 通过类的全限定名获取对应的class字节码文件（涉及到类加载器、双亲委派）
2. 将字节码文件的静态存储结构转换为方法区中的运行时存储结构
3. 在堆中生成一个代表这个类的java.lang.Class对象，作为
访问这个类的各种数据的入口
###验证

###准备
准备阶段是对类变量分配内存并赋默认值（如果int类型的默认值是0）的过程。这些类变量使用的
内存都在方法区中分配。这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。

这里的默认值指的是对应数据类型的零值，假设一个类变量的定义为：
```
public static int value = 123;
```
那么在准备阶段赋给value的值为int类型的默认值0，而不是123。123是在类初始化
阶段赋的值。而对于final static修饰的常量，会在准备阶段就赋值123，而不是0。
如果类变量是final的，那么编译器在编译时就会为value生成ConstantValue属性，并在准备阶段虚拟机就会根据ConstantValue的设置将变量设置为指定的值。
```
public static final int value = 123;
```
###解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

###初始化
类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。

在准备阶段，变量已经赋过一次系统要求的初始值(零值)；而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者更直接地说：初始化阶段是执行**静态代码块和为非final修饰的静态变量**赋值的过程。

静态变量和静态代码块是按照顺序执行的。但是静态代码块可以为后面的静态变量赋值，但不能访问。
```
public class Test{
    static{
        i=0;
        System.out.println(i);//Error：Cannot reference a field before it is defined（非法向前应用）
    }
    static int i=1;
}
```
改成下面情形，程序就可以编译通过并可以正常运行了:
```
public class Test{
    static{
        i=0;
        //System.out.println(i);
    }

    static int i=1;

    public static void main(String args[]){
        System.out.println(i);
    }
}/* Output: 
        1
 *///:~
```
###加载时机
虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。
虽然没有规定类的加载时机，但是规定了类的初始化时机。
###初始化时机
初始化一定发生在准备之后。

虚拟机规定了在以下情况下必须进行初始化：
* 使用new关键字实例化对象的时候
* 设置或读取一个类的静态变量的时候（被final static修饰的常量除外，因为它们在编译器就已经将字面量放到了常量池）
* 调用一个类的静态方法的时候
* 对类进行反射调用的时候
* 初始化类的时候，如果其父类还没有初始化，则先初始化其父类
* 当虚拟机启动时，虚拟机会先初始化主类（有main方法的类）

###类的初始化和实例化的区别
类的初始化是类经过准备阶段之后，为类变量赋值的过程。而类的实例化是创建一个类的实例。它们之间
是类和实例的关系，类只有一个，但可以有很多个实例。